package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/arikkfir/greenstar/backend/auth"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/arikkfir/greenstar/backend/public/gql"
	"github.com/arikkfir/greenstar/backend/public/model"
	"github.com/google/uuid"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, accountID *string, account model.AccountChanges) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	var id string
	if accountID == nil {
		id = uuid.NewString()
	} else {
		id = *accountID
	}

	createAccountParams := map[string]interface{}{}

	createAccountQuery := `// Create account
CREATE (account:Account {accountID: $accountID, displayName: $displayName})`
	createAccountParams["accountID"] = id
	createAccountParams["displayName"] = account.DisplayName

	if account.ParentID != nil {
		createAccountQuery += "WITH account\n"
		createAccountQuery += "MATCH (parent:Account {accountID: $parentAccountID}) \n"
		createAccountQuery += "CREATE (account)-[:ChildOf]->(parent)\n"
		createAccountParams["parentAccountID"] = account.ParentID
	}

	for i, kv := range account.Labels {
		createAccountQuery += fmt.Sprintf("MERGE (label:Label {name: $labelName%d})\n", i)
		createAccountQuery += fmt.Sprintf("MERGE (account)-[r:HasLabel {value: $labelValue%d}]->(label)\n", i)
		createAccountParams["labelName"+strconv.Itoa(i)] = kv.Key
		createAccountParams["labelValue"+strconv.Itoa(i)] = kv.Value
	}

	createAccountQuery += "RETURN account.id, account.displayName"

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		result, err := tx.Run(ctx, createAccountQuery, createAccountParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		record, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		return &model.Account{
			ID:          record.Values[0].(string),
			DisplayName: record.Values[1].(string),
		}, nil
	})
	if v == nil {
		return nil, err
	} else {
		return v.(*model.Account), err
	}
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, accountID string, account model.AccountChanges) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	updateAccountParams := map[string]interface{}{}

	updateAccountQuery := `// Update account
MATCH (account:Account {accountID: $accountID}) `
	updateAccountParams["accountID"] = accountID

	if account.DisplayName != nil {
		updateAccountQuery += "SET account.displayName = $displayName\n"
		updateAccountParams["displayName"] = *account.DisplayName
	}

	if account.ParentID != nil {
		updateAccountQuery += "WITH account\n"
		updateAccountQuery += "OPTIONAL MATCH (account)-[oldChildOfRel:ChildOf]->(oldParent:Account)\n"
		updateAccountQuery += "WHERE oldParent.accountID <> $parentAccountID\n"
		updateAccountQuery += "DELETE oldChildOfRel\n"
		updateAccountQuery += "WITH account\n"
		updateAccountQuery += "MERGE (parent:Account {accountID: $parentAccountID})\n"
		updateAccountQuery += "MERGE (account)-[:ChildOf]->(parent)\n"
		updateAccountParams["parentAccountID"] = *account.ParentID
	}

	for i, kv := range account.Labels {
		updateAccountQuery += "OPTIONAL MATCH (account)-[oldLabelRel:HasLabel]->(:Label)\n"
		updateAccountQuery += "DELETE oldLabelRel\n"
		updateAccountQuery += "WITH account\n"
		updateAccountQuery += fmt.Sprintf("MERGE (label:Label {name: $labelName%d})\n", i)
		updateAccountQuery += fmt.Sprintf("MERGE (account)-[r:HasLabel {value: $labelValue%d}]->(label)\n", i)
		updateAccountParams["labelName"+strconv.Itoa(i)] = kv.Key
		updateAccountParams["labelValue"+strconv.Itoa(i)] = kv.Value
	}

	updateAccountQuery += "RETURN account.id, account.displayName"

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		result, err := tx.Run(ctx, updateAccountQuery, updateAccountParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		record, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		return &model.Account{
			ID:          record.Values[0].(string),
			DisplayName: record.Values[1].(string),
		}, nil
	})
	return v.(*model.Account), err
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, accountID string) (string, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const deleteAccountQuery = `// Delete account
MATCH (account:Account {accountID: $accountID})
DELETE account`

		result, err := tx.Run(ctx, deleteAccountQuery, map[string]any{"accountID": accountID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		summary, err := result.Consume(ctx)
		if err != nil {
			return "", fmt.Errorf("failed to consume query summary: %w", err)
		}

		if summary.Counters().NodesDeleted() != 1 {
			return accountID, fmt.Errorf("no records deleted")
		}
		return accountID, nil
	})
	return v.(string), err
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, transaction model.TransactionChanges) (*model.Transaction, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		id := uuid.NewString()

		createTxQuery := `// Create transaction
MATCH (sourceAccount:Account {accountID: $sourceAccountID})
MATCH (targetAccount:Account {accountID: $targetAccountID})
CREATE (sourceAccount)-[r:TransferredTo {txID: $id, date: $date, refID: $refID, amount: $amount, description: $description}]->(targetAccount)
RETURN sourceAccount.id, sourceAccount.displayName, r, targetAccount.id, targetAccount.displayName`
		createTxParams := map[string]interface{}{}
		createTxParams["sourceAccountID"] = transaction.SourceAccountID
		createTxParams["targetAccountID"] = transaction.TargetAccountID
		createTxParams["id"] = id
		createTxParams["date"] = transaction.Date
		createTxParams["refID"] = transaction.ReferenceID
		createTxParams["amount"] = transaction.Amount
		createTxParams["description"] = transaction.Description

		result, err := tx.Run(ctx, createTxQuery, createTxParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		rec, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		txRel := rec.Values[2].(neo4j.Relationship)
		return &model.Transaction{
			ID:            txRel.Props["txID"].(string),
			Date:          txRel.Props["date"].(time.Time),
			TargetAccount: &model.Account{ID: rec.Values[3].(string), DisplayName: rec.Values[4].(string)},
			SourceAccount: &model.Account{ID: rec.Values[0].(string), DisplayName: rec.Values[1].(string)},
			ReferenceID:   txRel.Props["refID"].(string),
			Amount:        txRel.Props["amount"].(model.Money),
			Description:   txRel.Props["description"].(string),
		}, nil
	})
	return v.(*model.Transaction), err
}

// CreateTransactions is the resolver for the createTransactions field.
func (r *mutationResolver) CreateTransactions(ctx context.Context, transactions []*model.TransactionChanges) (int, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		createTxQuery := `// Create transactions list`
		createTxParams := map[string]interface{}{}

		for i, input := range transactions {
			createTxQuery += fmt.Sprintf(`// Create transaction %d
MATCH (sourceAccount%d:Account {accountID: $sourceAccountID%d})
MATCH (targetAccount%d:Account {accountID: $targetAccountID%d})
CREATE (sourceAccount%d)-[:TransferredTo {
	txID: $id%d, 
	date: $date%d, 
	refID: $refID%d, 
	amount: $amount%d, 
	description: $description%d
}]->(targetAccount%d)`,
				i, i, i, i, i, i, i, i, i, i, i, i)
			createTxParams["sourceAccountID"+strconv.Itoa(i)] = input.SourceAccountID
			createTxParams["targetAccountID"+strconv.Itoa(i)] = input.TargetAccountID
			createTxParams["id"+strconv.Itoa(i)] = uuid.NewString()
			createTxParams["date"+strconv.Itoa(i)] = input.Date
			createTxParams["refID"+strconv.Itoa(i)] = input.ReferenceID
			createTxParams["amount"+strconv.Itoa(i)] = input.Amount
			createTxParams["description"+strconv.Itoa(i)] = input.Description
		}

		result, err := tx.Run(ctx, createTxQuery, createTxParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		summary, err := result.Consume(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to consume query summary: %w", err)
		}

		relationshipsCreated := summary.Counters().RelationshipsCreated()
		if relationshipsCreated != len(transactions) {
			return nil, fmt.Errorf("incorrect number of transaction relationships created, expected %d, got %d", len(transactions), relationshipsCreated)
		}

		return relationshipsCreated, nil
	})
	return v.(int), err
}

// UploadTransactionsXLSFile is the resolver for the uploadTransactionsXLSFile field.
func (r *mutationResolver) UploadTransactionsXLSFile(ctx context.Context, file graphql.Upload) (bool, error) {
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return false, fmt.Errorf("failed to read uploaded file: %w", err)
	}

	msg, err := json.Marshal(fileBytes)
	if err != nil {
		return false, fmt.Errorf("failed to marshal XLS conversion request to JSON: %w", err)
	}

	cmd := r.Redis.B().Publish().Channel("convert-xls-to-xlsx").Message(auth.GetSession(ctx).Tenant + ":" + string(msg)).Build()
	if resp := r.Redis.Do(ctx, cmd); resp.Error() != nil {
		return false, fmt.Errorf("failed to publish request: %w", resp.Error())
	}

	return true, nil
}

// UploadTransactionsXLSXFile is the resolver for the uploadTransactionsXLSXFile field.
func (r *mutationResolver) UploadTransactionsXLSXFile(ctx context.Context, file graphql.Upload) (bool, error) {
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return false, fmt.Errorf("failed to read uploaded file: %w", err)
	}

	msg, err := json.Marshal(fileBytes)
	if err != nil {
		return false, fmt.Errorf("failed to marshal XLS conversion request to JSON: %w", err)
	}

	cmd := r.Redis.B().Publish().Channel(processXLSXChannelName).Message(auth.GetSession(ctx).Tenant + ":" + string(msg)).Build()
	if resp := r.Redis.Do(ctx, cmd); resp.Error() != nil {
		return false, fmt.Errorf("failed to publish request: %w", resp.Error())
	}

	return true, nil
}

// Mutation returns gql.MutationResolver implementation.
func (r *Resolver) Mutation() gql.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
