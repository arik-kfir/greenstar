package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"time"

	"github.com/arik-kfir/greenstar/backend/public/gql"
	"github.com/arik-kfir/greenstar/backend/public/model"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getAccountCypher = `// Get account by ID
MATCH (account:Account {id: $accountID})
RETURN account.id, account.displayName`

		result, err := tx.Run(ctx, getAccountCypher, map[string]any{"accountID": id})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		record, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect record: %w", err)
		}

		return &model.Account{
			ID:          record.Values[0].(string),
			DisplayName: record.Values[1].(string),
		}, nil
	})
	return v.(*model.Account), err
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, roots bool) ([]*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getRootAccountsCypher = `// Get root accounts
MATCH (a:Account) 
WHERE NOT exists ((a)-[:ChildOf]->(:Account)) 
RETURN a.id, a.displayName`
		const getAllAccountsCypher = `// Get all accounts
MATCH (a:Account) 
RETURN a.id, a.displayName`

		query := getAllAccountsCypher
		if roots {
			query = getRootAccountsCypher
		}
		result, err := tx.Run(ctx, query, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		accounts := make([]*model.Account, 0)
		for _, rec := range records {
			accounts = append(accounts, &model.Account{
				ID:          rec.Values[0].(string),
				DisplayName: rec.Values[1].(string),
			})
		}
		return accounts, nil
	})
	return v.([]*model.Account), err
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context) ([]*model.Transaction, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getTxQuery = `// Get databases representing tenants
MATCH (src:Account)-[tx:Transaction]->(dst:Account)
RETURN src.id, src.displayName, dst.id, dst.displayName, tx.id, tx.date, tx.referenceID, tx.amount, tx.description`

		result, err := tx.Run(ctx, getTxQuery, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		transactions := make([]*model.Transaction, 0)
		for _, rec := range records {
			src := &model.Account{ID: rec.Values[0].(string), DisplayName: rec.Values[1].(string)}
			dst := &model.Account{ID: rec.Values[2].(string), DisplayName: rec.Values[3].(string)}
			transactions = append(transactions, &model.Transaction{
				ID:            rec.Values[4].(string),
				Date:          rec.Values[5].(time.Time),
				TargetAccount: dst,
				SourceAccount: src,
				ReferenceID:   rec.Values[6].(string),
				Amount:        model.MustParseMoney(rec.Values[7].(string)),
				Description:   rec.Values[8].(string),
			})
		}
		return transactions, nil
	})
	return v.([]*model.Transaction), err
}

// Query returns gql.QueryResolver implementation.
func (r *Resolver) Query() gql.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
