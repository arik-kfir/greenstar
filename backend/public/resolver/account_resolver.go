package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"time"

	"github.com/arik-kfir/greenstar/backend/public/gql"
	"github.com/arik-kfir/greenstar/backend/public/model"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// Labels is the resolver for the labels field.
func (r *accountResolver) Labels(ctx context.Context, obj *model.Account) ([]*model.KeyAndValue, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getLabelsCypher = `// Get account labels
MATCH (acc:Account {accountID: $accountID})-[r:HasLabel]->(l:Label)
RETURN l.name, r.value`

		result, err := tx.Run(ctx, getLabelsCypher, map[string]any{"accountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		var labels []*model.KeyAndValue
		for _, record := range records {
			labels = append(labels, &model.KeyAndValue{
				Key:   record.Values[0].(string),
				Value: record.Values[1].(string),
			})
		}
		return labels, nil
	})
	return v.([]*model.KeyAndValue), err
}

// Children is the resolver for the children field.
func (r *accountResolver) Children(ctx context.Context, obj *model.Account) ([]*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getChildrenCypher = `// Get account children
MATCH (acc:Account)-[:ChildOf]->(parent:Account {accountID: $accountID})
RETURN acc.id, acc.displayName`

		result, err := tx.Run(ctx, getChildrenCypher, map[string]any{"accountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		accounts := make([]*model.Account, 0)
		for _, rec := range records {
			accounts = append(accounts, &model.Account{
				ID:          rec.Values[0].(string),
				DisplayName: rec.Values[1].(string),
			})
		}
		return accounts, nil
	})
	return v.([]*model.Account), err
}

// Parent is the resolver for the parent field.
func (r *accountResolver) Parent(ctx context.Context, obj *model.Account) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getParentCypher = `// Get account parent
MATCH (child:Account {accountID: $accountID})-[:ChildOf]->(parent:Account) 
RETURN parent.id, parent.displayName`

		result, err := tx.Run(ctx, getParentCypher, map[string]any{"accountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		if len(records) == 0 {
			return nil, nil
		}

		if len(records) > 1 {
			return nil, fmt.Errorf("too many records")
		}

		return &model.Account{
			ID:          records[0].Values[0].(string),
			DisplayName: records[0].Values[1].(string),
		}, nil
	})
	return v.(*model.Account), err
}

// OutgoingTransactions is the resolver for the outgoingTransactions field.
func (r *accountResolver) OutgoingTransactions(ctx context.Context, obj *model.Account) ([]*model.Transaction, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getTxQuery = `// Get databases representing tenants
MATCH (origin:Account {id: $sourceAccountID})
MATCH (src:Account)-[tx:Transaction]->(dst:Account)
WHERE exists ( (origin)-[:ChildOf*0..]->(src) )
RETURN src.id, src.displayName, dst.id, dst.displayName, tx.id, tx.date, tx.referenceID, tx.amount, tx.description`

		result, err := tx.Run(ctx, getTxQuery, map[string]any{"sourceAccountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		transactions := make([]*model.Transaction, 0)
		for _, rec := range records {
			src := &model.Account{ID: rec.Values[0].(string), DisplayName: rec.Values[1].(string)}
			dst := &model.Account{ID: rec.Values[2].(string), DisplayName: rec.Values[3].(string)}
			transactions = append(transactions, &model.Transaction{
				ID:            rec.Values[4].(string),
				Date:          rec.Values[5].(time.Time),
				TargetAccount: dst,
				SourceAccount: src,
				ReferenceID:   rec.Values[6].(string),
				Amount:        model.MustParseMoney(rec.Values[7].(string)),
				Description:   rec.Values[8].(string),
			})
		}
		return transactions, nil
	})
	return v.([]*model.Transaction), err
}

// IncomingTransactions is the resolver for the incomingTransactions field.
func (r *accountResolver) IncomingTransactions(ctx context.Context, obj *model.Account) ([]*model.Transaction, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getTxQuery = `// Get databases representing tenants
MATCH (target:Account {id: $targetAccountID})
MATCH (src:Account)-[tx:Transaction]->(dst:Account)
WHERE exists ( (target)-[:ChildOf*0..]->(dst) )
RETURN src.id, src.displayName, dst.id, dst.displayName, tx.id, tx.date, tx.referenceID, tx.amount, tx.description`

		result, err := tx.Run(ctx, getTxQuery, map[string]any{"targetAccountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		transactions := make([]*model.Transaction, 0)
		for _, rec := range records {
			src := &model.Account{ID: rec.Values[0].(string), DisplayName: rec.Values[1].(string)}
			dst := &model.Account{ID: rec.Values[2].(string), DisplayName: rec.Values[3].(string)}
			transactions = append(transactions, &model.Transaction{
				ID:            rec.Values[4].(string),
				Date:          rec.Values[5].(time.Time),
				TargetAccount: dst,
				SourceAccount: src,
				ReferenceID:   rec.Values[6].(string),
				Amount:        model.MustParseMoney(rec.Values[7].(string)),
				Description:   rec.Values[8].(string),
			})
		}
		return transactions, nil
	})
	return v.([]*model.Transaction), err
}

// Account returns gql.AccountResolver implementation.
func (r *Resolver) Account() gql.AccountResolver { return &accountResolver{r} }

type accountResolver struct{ *Resolver }
