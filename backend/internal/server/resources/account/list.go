// Code generated by greenstar scripts; DO NOT EDIT.

package account

import (
	"errors"
	"fmt"
	"net/http"
	"slices"
	"strconv"
	"strings"

	"github.com/arikkfir/greenstar/backend/internal/auth"
	"github.com/arikkfir/greenstar/backend/internal/server/util"
	"github.com/arikkfir/greenstar/backend/internal/util/lang"
)

var (
	sortableColumns = []string{"id"}
)

func init() {
	sortableColumns = append(sortableColumns, "displayName")
}

type ListRequest struct {
	properties  []string
	TenantID    string
	Offset      *uint    `url:"_offset,omitempty"`
	Count       *uint    `url:"_count,omitempty"`
	Sort        []string `url:"_sort,omitempty"`
	Currency    *string  `url:"currency,omitempty"`
	DisplayName *string  `url:"displayName,omitempty"`
}

func (lr *ListRequest) HasCurrency() bool    { return slices.Contains(lr.properties, "currency") }
func (lr *ListRequest) HasDisplayName() bool { return slices.Contains(lr.properties, "displayName") }
func (lr *ListRequest) UnmarshalFromRequest(r *http.Request) error {
	lr.properties = nil

	values := r.Form
	lr.TenantID = r.PathValue("tenantID")
	if lr.TenantID == "" {
		return fmt.Errorf("%w: tenant ID is required", util.ErrBadRequest)
	}
	if values.Has("currency") {
		lr.properties = append(lr.properties, "currency")
		if rawValue := values.Get("currency"); rawValue == util.QueryNilValue {
			return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "currency")
		} else {
			sv := lang.PtrOf(rawValue)
			lr.Currency = sv
		}
	}
	if values.Has("displayName") {
		lr.properties = append(lr.properties, "displayName")
		if rawValue := values.Get("displayName"); rawValue == util.QueryNilValue {
			return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "displayName")
		} else {
			sv := lang.PtrOf(rawValue)
			lr.DisplayName = sv
		}
	}

	lr.Offset = nil
	if values.Has("_offset") {
		if v, err := strconv.ParseUint(values.Get("_offset"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid offset '%s'", util.ErrBadRequest, values.Get("_offset"))
		} else {
			lr.Offset = lang.PtrOf(uint(v))
		}
	}

	lr.Count = nil
	if values.Has("_count") {
		if v, err := strconv.ParseUint(values.Get("_count"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid count '%s'", util.ErrBadRequest, values.Get("_count"))
		} else {
			lr.Count = lang.PtrOf(uint(v))
		}
	}

	lr.Sort = nil
	if values.Has("_sort") {
		if sort := values.Get("_sort"); sort != "" {
			lr.Sort = strings.Split(sort, ",")
			for _, s := range lr.Sort {
				sortTokens := strings.Split(s, ":")
				var col, dir string
				if len(sortTokens) == 1 {
					col = sortTokens[0]
					dir = "asc"
				} else if len(sortTokens) == 2 {
					col = sortTokens[0]
					dir = strings.ToLower(sortTokens[1])
				} else {
					return fmt.Errorf("%w: invalid sort spec '%s'", util.ErrBadRequest, s)
				}
				if dir != "asc" && dir != "desc" {
					return fmt.Errorf("%w: invalid sort direction in '%s'", util.ErrBadRequest, s)
				} else if !slices.Contains(sortableColumns, col) {
					return fmt.Errorf("%w: column '%s' is not sortable", util.ErrBadRequest, col)
				}
			}
		}
	}

	return nil
}

type ListResponse struct {
	TotalCount uint      `json:"totalCount"`
	Items      []Account `json:"items"`
}

func (s *Server) List(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	l := util.Logger(ctx)
	if !auth.GetToken(ctx).IsPermittedForTenant(r.PathValue("tenantID"), "accounts:read") {
		util.ServeError(w, r, util.ErrForbidden)
		l.With("tenantID", r.PathValue("TenantPathVariableName")).WarnContext(ctx, "Access denied", "permission", "accounts:read")
		return
	}

	if err := r.ParseForm(); err != nil {
		util.ServeError(w, r, errors.Join(util.ErrBadRequest, err))
		return
	}

	req := ListRequest{}
	if err := req.UnmarshalFromRequest(r); err != nil {
		util.ServeError(w, r, err)
		return
	}

	res, err := s.h.List(ctx, req)
	if err != nil {
		if code := util.ServeError(w, r, err); code >= http.StatusInternalServerError {
			l.ErrorContext(ctx, "Failed listing accounts", "err", err)
		}
		return
	}

	type ResponseWithOffset struct {
		Offset *uint `json:"offset,omitempty"`
		ListResponse
	}

	resWithOffset := ResponseWithOffset{
		Offset:       req.Offset,
		ListResponse: *res,
	}
	if err := util.Marshal(w, r, http.StatusOK, resWithOffset); err != nil {
		l.ErrorContext(ctx, "Failed marshaling accounts", "err", err)
		util.ServeError(w, r, err)
	}
}
