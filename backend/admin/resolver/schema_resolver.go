package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/arikkfir/greenstar/backend/admin/gql"
	"github.com/arikkfir/greenstar/backend/admin/model"
	"github.com/google/uuid"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// CreateTenant is the resolver for the createTenant field.
func (r *mutationResolver) CreateTenant(ctx context.Context, tenantID *string, tenant model.TenantChanges) (*model.Tenant, error) {
	var id string
	if tenantID == nil {
		id = uuid.NewString()
	} else {
		id = *tenantID
	}

	createDBSession := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer createDBSession.Close(ctx)

	_, err := createDBSession.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		//goland:noinspection SqlNoDataSourceInspection
		const createTenantDBQuery = `CREATE DATABASE $id IF NOT EXISTS`
		_, err := tx.Run(ctx, createTenantDBQuery, map[string]any{"id": id})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}
		return nil, nil
	})
	if err != nil {
		return nil, err
	}

	tenantDBSession := r.getNeo4jSessionForTenant(ctx, neo4j.AccessModeRead, id)
	defer tenantDBSession.Close(ctx)
	result, err := tenantDBSession.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const createTenantNodeQuery = `// Create a tenant
CREATE (tenant:Tenant {id: $id, displayName: $displayName}) 
RETURN tenant.id, tenant.displayName`
		result, err := tx.Run(ctx, createTenantNodeQuery, map[string]any{
			"id":          tenantID,
			"displayName": tenant.DisplayName,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		rec, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve record: %w", err)
		}
		return &model.Tenant{ID: rec.Values[0].(string), DisplayName: rec.Values[1].(string)}, nil
	})
	if err != nil {
		return nil, err
	} else {
		return result.(*model.Tenant), nil
	}
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, tenantID string, tenant model.TenantChanges) (*model.Tenant, error) {
	session := r.getNeo4jSessionForTenant(ctx, neo4j.AccessModeRead, tenantID)
	defer session.Close(ctx)

	result, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const updateTenantQuery = `MATCH (t:Tenant) SET t.displayName=$displayName RETURN t.id, t.displayName`
		result, err := tx.Run(ctx, updateTenantQuery, map[string]any{"displayName": tenant.DisplayName})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		rec, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve record: %w", err)
		}

		return &model.Tenant{
			ID:          rec.Values[0].(string),
			DisplayName: rec.Values[1].(string),
		}, nil
	})
	return result.(*model.Tenant), err
}

// DeleteTenant is the resolver for the deleteTenant field.
func (r *mutationResolver) DeleteTenant(ctx context.Context, tenantID string) (string, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		//goland:noinspection SqlNoDataSourceInspection
		const deleteTenantDBQuery = `DROP DATABASE $id IF EXISTS`
		_, err := tx.Run(ctx, deleteTenantDBQuery, map[string]any{"id": tenantID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		} else {
			return tenantID, nil
		}
	})
	if err != nil {
		return "", err
	} else {
		return tenantID, nil
	}
}

// Tenants is the resolver for the tenants field.
func (r *queryResolver) Tenants(ctx context.Context) ([]*model.Tenant, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const showDatabasesQuery = `// Get databases representing tenants
SHOW DATABASES
WHERE type = 'standard' AND name <> 'global'
YIELD name
RETURN name AS id`

		result, err := tx.Run(ctx, showDatabasesQuery, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		fetchTenant := func(tenantID string) (*model.Tenant, error) {
			session := r.getNeo4jSessionForTenant(ctx, neo4j.AccessModeRead, tenantID)
			defer session.Close(ctx)

			tenant, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
				const getTenantQuery = `// Get tenant query
MATCH (t:Tenant)
RETURN t.id, t.displayName`
				result, err := tx.Run(ctx, getTenantQuery, nil)
				if err != nil {
					return nil, fmt.Errorf("failed to execute query: %w", err)
				}

				rec, err := result.Single(ctx)
				if err != nil {
					return nil, fmt.Errorf("failed to retrieve record: %w", err)
				}
				return &model.Tenant{ID: rec.Values[0].(string), DisplayName: rec.Values[1].(string)}, nil
			})
			if err != nil {
				return nil, fmt.Errorf("failed to fetch tenant: %w", err)
			} else {
				return tenant.(*model.Tenant), nil
			}
		}

		tenants := make([]*model.Tenant, 0)
		for _, dbRec := range records {
			tenantID := dbRec.Values[0].(string)
			tenant, err := fetchTenant(tenantID)
			if err != nil {
				return nil, fmt.Errorf("failed to fetch tenant '%s': %w", tenantID, err)
			}
			tenants = append(tenants, tenant)
		}
		return tenants, nil
	})
	return v.([]*model.Tenant), err
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context, id string) (*model.Tenant, error) {
	session := r.getNeo4jSessionForTenant(ctx, neo4j.AccessModeRead, id)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		const getTenantQuery = `// Get tenant query
MATCH (t:Tenant)
RETURN t.id, t.displayName`

		result, err := tx.Run(ctx, getTenantQuery, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to execute get-tenant query: %w", err)
		}

		tenantRec, err := result.Single(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect tenant record: %w", err)
		}

		return &model.Tenant{
			ID:          tenantRec.Values[0].(string),
			DisplayName: tenantRec.Values[1].(string),
		}, nil
	})
	return v.(*model.Tenant), err
}

// Mutation returns gql.MutationResolver implementation.
func (r *Resolver) Mutation() gql.MutationResolver { return &mutationResolver{r} }

// Query returns gql.QueryResolver implementation.
func (r *Resolver) Query() gql.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
