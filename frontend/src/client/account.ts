// This file is generated by greenstar scripts. DO NOT EDIT.
// noinspection DuplicatedCode

import {QueryNilValue, BaseAPIURL} from "./common.ts"
import {useTenantID} from "./common.ts"
import {BadRequestError, InternalError} from "./errors.ts"
import {useDescope, useSession} from "@descope/react-sdk";
import {useMemo} from "react";

const slowEnvVar = import.meta.env.VITE_SLOW_REQUESTS
const slowEnvVarLower = slowEnvVar ? slowEnvVar.toLowerCase() : "false"
const slow = slowEnvVarLower == "true" || slowEnvVarLower == "t" || slowEnvVarLower == "1" || slowEnvVarLower == "y" || slowEnvVarLower == "yes"
const slowDuration = 2000
const dateProperties = [
    "createdAt",
    "updatedAt",
]

interface DescopeSdk {
    logout(token?: string): Promise<any>
}

export interface Account {
    id: string
    createdAt: Date
    updatedAt: Date
    balance?: number
    displayName: string
    icon?: string
    parentID?: string
    totalIncomingAmount?: number
    totalOutgoingAmount?: number
}

function jsonReviver(key: string, value: any): any {
    if (dateProperties.includes(key)) {
        return new Date(value);
    }
    return value;
}
export interface ListAccountsRequest {
    offset?: number
    count?: number
    sort?: string[]
    currency?: string
    displayName?: string
}
export interface ListAccountsResponse {
    offset: number
    totalCount: number
    items: Account[]
}
export interface CreateAccountRequest {
    balance?: number
    displayName: string
    icon?: string
    parentID?: string
    totalIncomingAmount?: number
    totalOutgoingAmount?: number
}
export type CreateAccountResponse = Account
export interface GetAccountRequest {
    id: string
}
export type GetAccountResponse = Account
export interface PatchAccountRequest {
    id: string
    balance?: number
    displayName?: string
    icon?: string
    parentID?: string
    totalIncomingAmount?: number
    totalOutgoingAmount?: number
}
export type PatchAccountResponse = Account

export interface UpdateAccountRequest {
    id: string
    balance?: number
    displayName: string
    icon?: string
    parentID?: string
    totalIncomingAmount?: number
    totalOutgoingAmount?: number
}
export type UpdateAccountResponse = Account
export interface DeleteAccountRequest {
    id: string
}
export interface DeleteAccountResponse {}

export interface AccountsClient {
    List(req?: ListAccountsRequest): Promise<ListAccountsResponse>
}

class AccountsClientImpl implements AccountsClient {

    private readonly listURL: string;
    constructor(private readonly sdk: DescopeSdk, private readonly sessionToken: string, tenantID: string) {
        this.listURL = BaseAPIURL + `/tenants/${tenantID}/accounts`
    }

    public async List(req?: ListAccountsRequest): Promise<ListAccountsResponse> {
        const urlParams = new URLSearchParams();

        if (req?.offset !== undefined && req.offset >= 0) {
            urlParams.set("_offset", req.offset+"")
        }
        if (req?.count !== undefined && req.count >= 0) {
            urlParams.set("_count", req.count+"")
        }
        if (req?.sort !== undefined && req?.sort.length) {
            req.sort.forEach(s => urlParams.append("_sort", s))
        }
        if (req?.currency !== undefined) {
            if (req?.currency === null) {
                urlParams.set("currency", QueryNilValue)
            } else {
                urlParams.set("currency", req?.currency)
            }
        }
        if (req?.displayName !== undefined) {
            if (req?.displayName === null) {
                urlParams.set("displayName", QueryNilValue)
            } else {
                urlParams.set("displayName", req?.displayName)
            }
        }

        let url = this.listURL;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Create(req: CreateAccountRequest): Promise<CreateAccountResponse> {
        const response = await fetch(this.listURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req)
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Get(req: GetAccountRequest): Promise<GetAccountResponse> {
        const urlParams = new URLSearchParams();

        let url = `${this.listURL}/${req.id}`;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Patch(req: PatchAccountRequest): Promise<PatchAccountResponse> {
        const response = await fetch(`${this.listURL}/${req.id}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req),
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Update(req: UpdateAccountRequest): Promise<UpdateAccountResponse> {
        const response = await fetch(`${this.listURL}/${req.id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req),
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Delete(req: DeleteAccountRequest): Promise<DeleteAccountResponse> {
        const urlParams = new URLSearchParams();

        let url = `${this.listURL}/${req.id}`;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }
}

export function useAccountsClient(): AccountsClient {
    const sdk = useDescope();
    const {sessionToken} = useSession();
    const tenantID = useTenantID();
    return useMemo(() => new AccountsClientImpl(sdk, sessionToken, tenantID), [sessionToken, tenantID])
}
