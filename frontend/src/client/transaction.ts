// This file is generated by greenstar scripts. DO NOT EDIT.
// noinspection DuplicatedCode

import {BaseAPIURL, QueryNilValue, useTenantID} from "./common.ts"
import {BadRequestError, InternalError} from "./errors.ts"
import {useDescope, useSession} from "@descope/react-sdk";
import {useMemo} from "react";

const slowEnvVar = import.meta.env.VITE_SLOW_REQUESTS
const slowEnvVarLower = slowEnvVar ? slowEnvVar.toLowerCase() : "false"
const slow = slowEnvVarLower == "true" || slowEnvVarLower == "t" || slowEnvVarLower == "1" || slowEnvVarLower == "y" || slowEnvVarLower == "yes"
const slowDuration = 2000
const dateProperties = [
    "createdAt",
    "updatedAt",
    "date",
]

interface DescopeSdk {
    logout(token?: string): Promise<any>
}

export interface Transaction {
    id: string
    createdAt: Date
    updatedAt: Date
    amount: number
    convertedAmount: number
    currency: string
    date: Date
    description?: string
    referenceId: string
    sourceAccountId: string
    targetAccountId: string
}

function jsonReviver(key: string, value: any): any {
    if (dateProperties.includes(key)) {
        return new Date(value);
    }
    return value;
}
export interface ListTransactionsRequest {
    offset?: number
    count?: number
    sort?: string[]
    currency?: string
    minDate?: Date
    maxDate?: Date
    referenceId?: string
    minAmount?: number
    maxAmount?: number
    description?: string
    sourceAccountId?: string
    targetAccountId?: string
}
export interface ListTransactionsResponse {
    offset: number
    totalCount: number
    items: Transaction[]
}
export interface CreateTransactionRequest {
    amount: number
    currency: string
    date: Date
    description?: string
    referenceId: string
    sourceAccountId: string
    targetAccountId: string
}
export type CreateTransactionResponse = Transaction
export interface GetTransactionRequest {
    id: string
}
export type GetTransactionResponse = Transaction
export interface PatchTransactionRequest {
    id: string
    amount?: number
    currency?: string
    date?: Date
    description?: string
    referenceId?: string
    sourceAccountId?: string
    targetAccountId?: string
}
export type PatchTransactionResponse = Transaction

export interface UpdateTransactionRequest {
    id: string
    amount: number
    currency: string
    date: Date
    description?: string
    referenceId: string
    sourceAccountId: string
    targetAccountId: string
}
export type UpdateTransactionResponse = Transaction
export interface DeleteTransactionRequest {
    id: string
}
export interface DeleteTransactionResponse {}

export interface TransactionsClient {
    List(req?: ListTransactionsRequest): Promise<ListTransactionsResponse>
}

class TransactionsClientImpl implements TransactionsClient {

    private readonly listURL: string;
    constructor(private readonly sdk: DescopeSdk, private readonly sessionToken: string, tenantID: string) {
        this.listURL = BaseAPIURL + `/tenants/${tenantID}/transactions`
    }

    public async List(req?: ListTransactionsRequest): Promise<ListTransactionsResponse> {
        const urlParams = new URLSearchParams();

        if (req?.offset !== undefined && req.offset >= 0) {
            urlParams.set("_offset", req.offset+"")
        }
        if (req?.count !== undefined && req.count >= 0) {
            urlParams.set("_count", req.count+"")
        }
        if (req?.sort !== undefined && req?.sort.length) {
            req.sort.forEach(s => urlParams.append("_sort", s))
        }
        if (req?.currency !== undefined) {
            if (req?.currency === null) {
                urlParams.set("currency", QueryNilValue)
            } else {
                urlParams.set("currency", req?.currency)
            }
        }
        if (req?.minDate !== undefined) {
            if (req?.minDate === null) {
                urlParams.set("minDate", QueryNilValue)
            } else {
                urlParams.set("minDate", req?.minDate.toISOString())
            }
        }
        if (req?.maxDate !== undefined) {
            if (req?.maxDate === null) {
                urlParams.set("maxDate", QueryNilValue)
            } else {
                urlParams.set("maxDate", req?.maxDate.toISOString())
            }
        }
        if (req?.referenceId !== undefined) {
            if (req?.referenceId === null) {
                urlParams.set("referenceId", QueryNilValue)
            } else {
                urlParams.set("referenceId", req?.referenceId)
            }
        }
        if (req?.minAmount !== undefined) {
            if (req?.minAmount === null) {
                urlParams.set("minAmount", QueryNilValue)
            } else {
                urlParams.set("minAmount", req?.minAmount+"")
            }
        }
        if (req?.maxAmount !== undefined) {
            if (req?.maxAmount === null) {
                urlParams.set("maxAmount", QueryNilValue)
            } else {
                urlParams.set("maxAmount", req?.maxAmount+"")
            }
        }
        if (req?.description !== undefined) {
            if (req?.description === null) {
                urlParams.set("description", QueryNilValue)
            } else {
                urlParams.set("description", req?.description)
            }
        }
        if (req?.sourceAccountId !== undefined) {
            if (req?.sourceAccountId === null) {
                urlParams.set("sourceAccountId", QueryNilValue)
            } else {
                urlParams.set("sourceAccountId", req?.sourceAccountId)
            }
        }
        if (req?.targetAccountId !== undefined) {
            if (req?.targetAccountId === null) {
                urlParams.set("targetAccountId", QueryNilValue)
            } else {
                urlParams.set("targetAccountId", req?.targetAccountId)
            }
        }

        let url = this.listURL;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Create(req: CreateTransactionRequest): Promise<CreateTransactionResponse> {
        const response = await fetch(this.listURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req)
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Get(req: GetTransactionRequest): Promise<GetTransactionResponse> {
        const urlParams = new URLSearchParams();

        let url = `${this.listURL}/${req.id}`;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Patch(req: PatchTransactionRequest): Promise<PatchTransactionResponse> {
        const response = await fetch(`${this.listURL}/${req.id}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req),
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Update(req: UpdateTransactionRequest): Promise<UpdateTransactionResponse> {
        const response = await fetch(`${this.listURL}/${req.id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req),
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Delete(req: DeleteTransactionRequest): Promise<DeleteTransactionResponse> {
        const urlParams = new URLSearchParams();

        let url = `${this.listURL}/${req.id}`;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }
}

export function useTransactionsClient(): TransactionsClient {
    const sdk = useDescope();
    const {sessionToken} = useSession();
    const tenantID = useTenantID();
    return useMemo(() => new TransactionsClientImpl(sdk, sessionToken, tenantID), [sessionToken, tenantID])
}
