// Code generated by greenstar scripts; DO NOT EDIT.

package {{ .model.Name | toSnake }}

{{- if ne .model.Update nil }}

import (
	"encoding/json"
	"github.com/arikkfir/greenstar/backend/internal/server/middleware"
	"github.com/arikkfir/greenstar/backend/internal/server/util"
	"github.com/shopspring/decimal"
	"net/http"
	"slices"
	"time"
)

var (
	_ = decimal.Decimal{}
	_ = time.Time{}
)

type PatchRequest struct {
	ID          string  `json:"id"`
	{{- range $name, $p := .model.Properties }}
	{{ $name }} *{{ $p.Type.GoType }} `json:"{{ $name | toLowerCamelCase }},omitempty"`
	{{- end }}
	properties  []string
}

{{- range $name, $p := .model.Properties }}
{{- if not .ReadOnly }}
func (lr *PatchRequest) Has{{ $name }}() bool { return slices.Contains(lr.properties, "{{ $name | toLowerCamelCase }}") }
{{- end }}
{{- end }}
func (lr *PatchRequest) UnmarshalJSON(data []byte) error {
	lr.properties = nil
	var tempMap map[string]json.RawMessage
	if err := json.Unmarshal(data, &tempMap); err != nil {
		return err
	}
	for key := range tempMap {
		lr.properties = append(lr.properties, key)
	}
	type typeAlias PatchRequest
	alias := (*typeAlias)(lr)
	if err := json.Unmarshal(data, alias); err != nil {
		return err
	}
	return nil
}

type PatchResponse {{ .model.Name }}

func (s *Server) Patch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	l := util.Logger(ctx)

	tenantID := middleware.GetTenantID(ctx)
	if tenantID != "" {
		l = l.With("tenantID", tenantID)
	}

	{{- if gt (len .model.Update.Permissions) 0 }}
	authToken := middleware.GetToken(ctx)

	{{- range .model.Update.Permissions }}
	if !authToken.IsPermittedGlobally("{{ . }}") {
		if tenantID != "" {
			if !authToken.IsPermittedForTenant(tenantID, "{{ . }}") {
				util.ServeError(w, r, util.ErrForbidden)
				l.WarnContext(ctx, "Access denied", "permission", "{{ . }}")
				return
			}
		} else {
			util.ServeError(w, r, util.ErrForbidden)
			l.WarnContext(ctx, "Access denied", "permission", "{{ . }}")
			return
		}
	}
	{{- end }}
	{{- end }}

	req := PatchRequest{}
	if err := util.UnmarshalBody(r, &req); err != nil {
		util.ServeError(w, r, err)
		return
	}

	req.ID = r.PathValue("id")
	if req.ID == "" {
		util.ServeError(w, r, util.ErrBadRequest)
		return
	}

	res, err := s.h.Patch(ctx, req)
	if err != nil {
		if code := util.ServeError(w, r, err); code >= http.StatusInternalServerError {
			l.ErrorContext(ctx, "Failed patching {{ .model.Name | lower }}", "err", err)
		}
		return
	} else if res == nil {
		util.ServeError(w, r, util.ErrNotFound)
		return
	}

	if err := util.Marshal(w, r, http.StatusOK, res); err != nil {
		l.ErrorContext(ctx, "Failed patching {{ .model.Name | lower }}", "err", err)
		util.ServeError(w, r, err)
	}
}

{{- end }}
