// This file is generated by greenstar scripts. DO NOT EDIT.
// noinspection DuplicatedCode

import {BaseAPIURL, QueryNilValue{{- if eq .model.Scope modelScopeTenant }}, useTenantID{{- end}}} from "./common.ts"
import {BadRequestError, InternalError} from "./errors.ts"
import {useDescope, useSession} from "@descope/react-sdk";
import {useMemo} from "react";

const slowEnvVar = import.meta.env.VITE_SLOW_REQUESTS
const slowEnvVarLower = slowEnvVar ? slowEnvVar.toLowerCase() : "false"
const slow = slowEnvVarLower == "true" || slowEnvVarLower == "t" || slowEnvVarLower == "1" || slowEnvVarLower == "y" || slowEnvVarLower == "yes"
const slowDuration = 2000
const dateProperties = [
    "createdAt",
    "updatedAt",
    {{- range .model.Properties }}
    {{- if eq .TypeScriptType "Date" }}
    "{{ .Name | toLowerCamelCase }}",
    {{- end }}
    {{- end }}
]

interface DescopeSdk {
    logout(token?: string): Promise<any>
}

export interface {{ .model.Name }} {
    id: string
    createdAt: Date
    updatedAt: Date
    {{- range .model.Properties }}
    {{ .Name | toLowerCamelCase }}{{ if .Optional }}?{{ end }}: {{ .TypeScriptType }}
    {{- end }}
}

function jsonReviver(key: string, value: any): any {
    if (dateProperties.includes(key)) {
        return new Date(value);
    }
    return value;
}

{{- if .model.List }}
export interface List{{ .model.Name | toPlural }}Request {
    offset?: number
    count?: number
    sort?: string[]
    {{- range .model.List.FilterProperties }}
    {{ .Name | toLowerCamelCase }}?: {{ .TypeScriptType }}
    {{- end }}
}
export interface List{{ .model.Name | toPlural }}Response {
    offset: number
    totalCount: number
    items: {{ .model.Name }}[]
}
{{- end }}

{{- if .model.Create }}
export interface Create{{ .model.Name }}Request {
    {{- if .model.Create.AllowExplicitID }}
    id?: string
    {{- end }}
    {{- range .model.Properties }}
    {{- if not .ReadOnly }}
    {{ .Name | toLowerCamelCase }}{{ if .Optional }}?{{ end }}: {{ .TypeScriptType }}
    {{- end }}
    {{- end }}
}
export type Create{{ .model.Name }}Response = {{ .model.Name }}
{{- end }}

{{- if .model.Get }}
export interface Get{{ .model.Name }}Request {
    id: string
}
export type Get{{ .model.Name }}Response = {{ .model.Name }}
{{- end }}

{{- if .model.Update }}
export interface Patch{{ .model.Name }}Request {
    id: string
    {{- range .model.Properties }}
    {{- if not .ReadOnly }}
    {{ .Name | toLowerCamelCase }}?: {{ .TypeScriptType }}
    {{- end }}
    {{- end }}
}
export type Patch{{ .model.Name }}Response = {{ .model.Name }}

export interface Update{{ .model.Name }}Request {
    id: string
    {{- range .model.Properties }}
    {{- if not .ReadOnly }}
    {{ .Name | toLowerCamelCase }}{{ if .Optional }}?{{ end }}: {{ .TypeScriptType }}
    {{- end }}
    {{- end }}
}
export type Update{{ .model.Name }}Response = {{ .model.Name }}
{{- end }}

{{- if .model.Delete }}
export interface Delete{{ .model.Name }}Request {
    id: string
}
export interface Delete{{ .model.Name }}Response {}
{{- end }}

export interface {{ .model.Name | toPlural }}Client {
    List(req?: List{{ .model.Name | toPlural }}Request): Promise<List{{ .model.Name | toPlural }}Response>
}

class {{ .model.Name | toPlural }}ClientImpl implements {{ .model.Name | toPlural }}Client {

    private readonly listURL: string;

    {{- if eq .model.Scope modelScopeTenant }}
    constructor(private readonly sdk: DescopeSdk, private readonly sessionToken: string, tenantID: string) {
        this.listURL = BaseAPIURL + `/tenants/${tenantID}{{ .model.Path }}`
    }
    {{- else }}
    constructor(private readonly sdk: DescopeSdk, private readonly sessionToken: string) {
        this.listURL = BaseAPIURL + "{{ .model.Path }}"
    }
    {{- end }}

    public async List(req?: List{{ .model.Name | toPlural }}Request): Promise<List{{ .model.Name | toPlural }}Response> {
        const urlParams = new URLSearchParams();

        if (req?.offset !== undefined && req.offset >= 0) {
            urlParams.set("_offset", req.offset+"")
        }
        if (req?.count !== undefined && req.count >= 0) {
            urlParams.set("_count", req.count+"")
        }
        if (req?.sort !== undefined && req?.sort.length) {
            req.sort.forEach(s => urlParams.append("_sort", s))
        }

        {{- range .model.List.FilterProperties }}
        if (req?.{{ .Name | toLowerCamelCase }} !== undefined) {
            if (req?.{{ .Name | toLowerCamelCase }} === null) {
                urlParams.set("{{ .Name | toLowerCamelCase }}", QueryNilValue)
            } else {
                {{- if eq .TypeScriptType "Date" }}
                urlParams.set("{{ .Name | toLowerCamelCase }}", req?.{{ .Name | toLowerCamelCase }}.toISOString())
                {{- else if eq .TypeScriptType "number" }}
                urlParams.set("{{ .Name | toLowerCamelCase }}", req?.{{ .Name | toLowerCamelCase }}+"")
                {{- else }}
                urlParams.set("{{ .Name | toLowerCamelCase }}", req?.{{ .Name | toLowerCamelCase }})
                {{- end }}
            }
        }
        {{- end }}

        let url = this.listURL;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Create(req: Create{{ .model.Name }}Request): Promise<Create{{ .model.Name }}Response> {
        const response = await fetch(this.listURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req)
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Get(req: Get{{ .model.Name }}Request): Promise<Get{{ .model.Name }}Response> {
        const urlParams = new URLSearchParams();

        let url = `${this.listURL}/${req.id}`;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Patch(req: Patch{{ .model.Name }}Request): Promise<Patch{{ .model.Name }}Response> {
        const response = await fetch(`${this.listURL}/${req.id}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req),
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Update(req: Update{{ .model.Name }}Request): Promise<Update{{ .model.Name }}Response> {
        const response = await fetch(`${this.listURL}/${req.id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.sessionToken}`,
            },
            body: JSON.stringify(req),
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }

    public async Delete(req: Delete{{ .model.Name }}Request): Promise<Delete{{ .model.Name }}Response> {
        const urlParams = new URLSearchParams();

        let url = `${this.listURL}/${req.id}`;
        if(urlParams.size) {
            url += "?" + urlParams.toString()
        }

        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${this.sessionToken}`,
            },
        }).then(r => slow ? new Promise((resolve: (v: Response) => void) => window.setTimeout(() => resolve(r), slowDuration)) : r)

        if (response.status >= 500) {
            const data = await response.text()
            console.error(`Server responded with an error status code ${response.status}: ${data}`)
            throw InternalError
        } else if (response.status == 401) {
            await this.sdk.logout()
            throw new Error('Logged out')
        } else if (response.status >= 400) {
            const data = await response.text()
            throw new BadRequestError(response.status, data)
        } else {
            return JSON.parse(await response.text(), jsonReviver)
        }
    }
}

export function use{{ .model.Name | toPlural }}Client(): {{ .model.Name | toPlural }}Client {
    const sdk = useDescope();
    const {sessionToken} = useSession();

    {{- if eq .model.Scope modelScopeTenant }}
    const tenantID = useTenantID();
    return useMemo(() => new {{ .model.Name | toPlural }}ClientImpl(sdk, sessionToken, tenantID), [sessionToken, tenantID])
    {{- else }}
    return useMemo(() => new {{ .model.Name | toPlural }}ClientImpl(sdk, sessionToken), [sessionToken])
    {{- end }}
}
