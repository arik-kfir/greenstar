{{- $importDecimal := false }}
{{- $importTime := false }}
{{- range .model.Properties }}
{{- if eq .GoType "decimal.Decimal" }}{{ $importDecimal = true }}{{- end }}
{{- if eq .GoType "time.Time" }}{{ $importTime = true }}{{- end }}
{{- end }}
// Code generated by greenstar scripts; DO NOT EDIT.

package {{ .model.Name | toSnake }}

{{- if ne .model.List nil }}

import (
	"errors"
	"fmt"
	"github.com/arikkfir/greenstar/backend/internal/auth"
	"github.com/arikkfir/greenstar/backend/internal/server/util"
	"github.com/arikkfir/greenstar/backend/internal/util/lang"
	"math"
	"strconv"
	"strings"



{{- if $importDecimal }}
	"github.com/shopspring/decimal"
	{{- end }}
	"net/http"
	"slices"
	{{- if $importTime }}
	"time"
	{{- end }}
)

var (
	sortableColumns = []string{"id"}
)

func init() {
	{{- range .model.Properties }}
	{{- if .Sortable }}
	sortableColumns = append(sortableColumns, "{{ .Name | toLowerCamelCase }}")
	{{- end }}
	{{- end }}
}

type ListRequest struct {
	properties  []string
	{{- if eq .model.Scope modelScopeTenant }}
	TenantID string
	{{- end }}
	Offset  *uint `url:"_offset,omitempty"`
	Count   *uint `url:"_count,omitempty"`
	Sort []string `url:"_sort,omitempty"`
	{{- range .model.List.FilterProperties }}
	{{ .Name }} *{{ .GoType }} `url:"{{ .Name | toLowerCamelCase }},omitempty"`
	{{- end }}
}

{{- range .model.List.FilterProperties }}
func (lr *ListRequest) Has{{ .Name }}() bool { return slices.Contains(lr.properties, "{{ .Name | toLowerCamelCase }}") }
{{- end }}
func (lr *ListRequest) UnmarshalFromRequest(r *http.Request) error {
	lr.properties = nil

	values := r.Form
	{{- if eq .model.Scope modelScopeTenant }}
	lr.TenantID = r.PathValue("tenantID")
	if lr.TenantID == "" {
		return fmt.Errorf("%w: tenant ID is required", util.ErrBadRequest)
	}
	{{- end }}

	{{- range .model.List.FilterProperties }}
	if values.Has("{{ .Name | toLowerCamelCase }}") {
		lr.properties = append(lr.properties, "{{ .Name | toLowerCamelCase }}")
		if rawValue := values.Get("{{ .Name | toLowerCamelCase }}"); rawValue == util.QueryNilValue {
			{{- if not .Optional }}
			return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "{{ .Name | toLowerCamelCase }}")
			{{- else }}
			lr.{{ .Name }} = nil
			{{- end }}
		} else {
			sv := lang.PtrOf(rawValue)
			{{- if eq .GoType "string" }}
			lr.{{ .Name }} = sv
			{{- else if eq .GoType "time.Time" }}
			if tv, err := time.Parse(time.RFC3339, *sv); err != nil {
				return err
			} else {
				lr.{{ .Name }} = lang.PtrOf(tv)
			}
			{{- else if eq .GoType "decimal.Decimal" }}
			if dv, err := decimal.NewFromString(*sv); err != nil {
				return err
			} else {
				lr.{{ .Name }} = lang.PtrOf(dv)
			}
			{{- else }}
			{{ fail "unsupported property type encountered in list filter property '%s' in model '%s': %s" .Name $.model.Name .GoType }}
			{{- end }}
		}
	}
	{{- end }}

	lr.Offset = nil
	if values.Has("_offset") {
		if v, err := strconv.ParseUint(values.Get("_offset"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid offset '%s'", util.ErrBadRequest, values.Get("_offset"))
		} else {
			lr.Offset = lang.PtrOf(uint(v))
		}
	}

	lr.Count = nil
	if values.Has("_count") {
		if v, err := strconv.ParseUint(values.Get("_count"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid count '%s'", util.ErrBadRequest, values.Get("_count"))
		} else {
			lr.Count = lang.PtrOf(uint(v))
		}
	}

	lr.Sort = nil
	if values.Has("_sort") {
		if sort := values.Get("_sort"); sort != "" {
			lr.Sort = strings.Split(sort, ",")
			for _, s := range lr.Sort {
				sortTokens := strings.Split(s, ":")
				var col, dir string
				if len(sortTokens) == 1 {
					col = sortTokens[0]
					dir = "asc"
				} else if len(sortTokens) == 2 {
					col = sortTokens[0]
					dir = strings.ToLower(sortTokens[1])
				} else {
					return fmt.Errorf("%w: invalid sort spec '%s'", util.ErrBadRequest, s)
				}
				if dir != "asc" && dir != "desc" {
					return fmt.Errorf("%w: invalid sort direction in '%s'", util.ErrBadRequest, s)
				} else if !slices.Contains(sortableColumns, col) {
					return fmt.Errorf("%w: column '%s' is not sortable", util.ErrBadRequest, col)
				}
			}
		}
	}

	return nil
}

type ListResponse struct {
	TotalCount uint      `json:"totalCount"`
	Items      []{{ .model.Name }} `json:"items"`
}

func (s *Server) List(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	l := util.Logger(ctx)
	{{- range .model.List.Permissions }}
	{{- if eq .Scope modelScopeGlobal }}
	if !auth.GetToken(ctx).IsPermittedGlobally("{{ .Permission }}") {
		util.ServeError(w, r, util.ErrForbidden)
		l.WarnContext(ctx, "Access denied", "permission", "{{ .Permission }}")
		return
	}
	{{- else if eq .Scope modelScopeTenant }}
	if !auth.GetToken(ctx).IsPermittedForTenant(r.PathValue("{{ .TenantPathVariableName }}"), "{{ .Permission }}") {
		util.ServeError(w, r, util.ErrForbidden)
		l.With("tenantID", r.PathValue("TenantPathVariableName")).WarnContext(ctx, "Access denied", "permission", "{{ .Permission }}")
		return
	}
	{{- else }}
	{{- fail "unknown model scope: %s" .Scope }}
	{{- end }}
	{{- end }}

	if err := r.ParseForm(); err != nil {
		util.ServeError(w, r, errors.Join(util.ErrBadRequest, err))
		return
	}

	req := ListRequest{}
	if err := req.UnmarshalFromRequest(r); err != nil {
		util.ServeError(w, r, err)
		return
	}

	res, err := s.h.List(ctx, req)
	if err != nil {
		if code := util.ServeError(w, r, err); code >= http.StatusInternalServerError {
			l.ErrorContext(ctx, "Failed listing {{ .model.Name | toPlural | lower }}", "err", err)
		}
		return
	}

	type ResponseWithOffset struct {
		Offset *uint      `json:"offset,omitempty"`
		ListResponse
	}

	resWithOffset := ResponseWithOffset{
		Offset: req.Offset,
		ListResponse: *res,
	}
	if err := util.Marshal(w, r, http.StatusOK, resWithOffset); err != nil {
		l.ErrorContext(ctx, "Failed marshaling {{ .model.Name | toPlural | lower }}", "err", err)
		util.ServeError(w, r, err)
	}
}

{{- end }}
