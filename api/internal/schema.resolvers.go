package internal

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/99designs/gqlgen/graphql"
	"github.com/arikkfir/greenstar/api/internal/model"
	xlsConverterPkg "github.com/arikkfir/greenstar/xlsconverter/pkg"
	"github.com/google/uuid"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
	"io"
)

// Children is the resolver for the children field.
func (r *accountResolver) Children(ctx context.Context, obj *model.Account) ([]*model.Account, error) {
	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	// language=Cypher
	const getChildrenCypher = `MATCH (child:Account)-[:ChildOf]->(parent:Account {accountID: $accountID}) RETURN child`
	result, err := session.Run(ctx, getChildrenCypher, map[string]any{"accountID": obj.ID})
	if err != nil {
		return nil, fmt.Errorf("failed to get child accounts: %w", err)
	}

	records, err := result.Collect(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get child account records: %w", err)
	}

	accounts := make([]*model.Account, 0)
	for _, rec := range records {
		node := rec.Values[0].(neo4j.Node)
		accounts = append(accounts, &model.Account{
			ID:          node.Props["accountID"].(string),
			DisplayName: node.Props["displayName"].(string),
			Labels:      nil, // TODO: fetch child node labels
			Annotations: nil, // TODO: fetch child node annotations
		})
	}
	return accounts, nil
}

// Parent is the resolver for the parent field.
func (r *accountResolver) Parent(ctx context.Context, obj *model.Account) (*model.Account, error) {
	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	// language=Cypher
	const getParentCypher = `MATCH (child:Account {accountID: $accountID})-[:ChildOf]->(parent:Account) RETURN parent`
	result, err := session.Run(ctx, getParentCypher, map[string]any{"accountID": obj.ID})
	if err != nil {
		return nil, fmt.Errorf("failed to get parent account: %w", err)
	}

	records, err := result.Collect(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get parent account records: %w", err)
	} else if len(records) == 0 {
		return nil, nil
	} else if len(records) > 1 {
		return nil, fmt.Errorf("failed to get parent account: more than one parent found")
	} else {
		node := records[0].Values[0].(neo4j.Node)
		account := &model.Account{
			ID:          node.Props["accountID"].(string),
			DisplayName: node.Props["displayName"].(string),
			Labels:      nil, // TODO: fetch parent node labels
			Annotations: nil, // TODO: fetch parent node annotations
		}
		return account, nil
	}
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input model.NewAccount) (*model.Account, error) {
	var id string
	if input.ID == nil {
		id = uuid.NewString()
	} else {
		id = *input.ID
	}

	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	query := `CREATE (account:Account {accountID: $accountID, displayName: $displayName})`
	if input.ParentID != nil {
		query += `
WITH account
MATCH (parent:Account {accountID: $parentAccountID}) CREATE (account)-[:ChildOf]->(parent)`
	}
	query += `
RETURN account`

	createAccountParams := map[string]interface{}{
		"accountID":       id,
		"displayName":     input.DisplayName,
		"parentAccountID": input.ParentID,
	}
	result, err := session.Run(ctx, query, createAccountParams)
	if err != nil {
		return nil, fmt.Errorf("failed to create account: %w", err)
	}

	record, err := result.Single(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get account record: %w", err)
	}

	node := record.Values[0].(neo4j.Node)
	return &model.Account{
		ID:          node.Props["accountID"].(string),
		DisplayName: node.Props["displayName"].(string),
		Labels:      nil, // TODO: fetch new account labels
		Annotations: nil, // TODO: fetch new account annotations
	}, nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, id string, input model.AccountUpdate) (*model.Account, error) {
	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	query := `MATCH (account:Account {accountID: $accountID})`
	if input.DisplayName != nil {
		query += `
SET account.displayName = $displayName`
	}
	// TODO: update account labels
	// TODO: update account annotations
	if input.ParentID != nil {
		query += `
WITH account
OPTIONAL MATCH (account)-[oldChildOfRel:ChildOf]->(oldParent:Account)
WHERE oldParent.accountID <> $parentAccountID
DELETE oldChildOfRel
WITH account
MERGE (account)-[:ChildOf]->(parent:Account {accountID: $parentAccountID})`
	}
	query += `
RETURN account`

	createAccountParams := map[string]interface{}{
		"accountID":       id,
		"displayName":     input.DisplayName,
		"parentAccountID": input.ParentID,
	}
	result, err := session.Run(ctx, query, createAccountParams)
	if err != nil {
		return nil, fmt.Errorf("failed to create account: %w", err)
	}

	record, err := result.Single(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get account record: %w", err)
	}

	node := record.Values[0].(neo4j.Node)
	return &model.Account{
		ID:          node.Props["accountID"].(string),
		DisplayName: node.Props["displayName"].(string),
		Labels:      nil, // TODO: fetch new account labels
		Annotations: nil, // TODO: fetch new account annotations
	}, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (string, error) {
	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	query := `MATCH (account:Account {accountID: $accountID}) DELETE account`
	if result, err := session.Run(ctx, query, map[string]interface{}{"accountID": id}); err != nil {
		return "", fmt.Errorf("failed to delete account: %w", err)
	} else if summary, err := result.Consume(ctx); err != nil {
		return "", fmt.Errorf("failed to consume results of deleting account: %w", err)
	} else if summary.Counters().NodesDeleted() != 1 {
		return "", fmt.Errorf("failed to delete account: no records deleted")
	} else {
		return id, nil
	}
}

// UploadTransactionsXLSFile is the resolver for the uploadTransactionsXLSFile field.
func (r *mutationResolver) UploadTransactionsXLSFile(ctx context.Context, file graphql.Upload) (bool, error) {
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return false, fmt.Errorf("failed to read uploaded file: %w", err)
	}

	req := &xlsConverterPkg.ConvertXLSFileToXLSXRequest{
		FileName: file.Filename,
		Data:     fileBytes,
		ReplyTo:  InputXLSXChannel,
	}
	if msgBytes, err := json.Marshal(req); err != nil {
		return false, fmt.Errorf("failed to marshal request: %w", err)
	} else if resp := r.Redis.Do(ctx, r.Redis.B().Publish().Channel(xlsConverterPkg.ChannelName).Message(string(msgBytes)).Build()); resp.Error() != nil {
		return false, fmt.Errorf("failed to publish request: %w", resp.Error())
	} else {
		return true, nil
	}
}

// UploadTransactionsXLSXFile is the resolver for the uploadTransactionsXLSXFile field.
func (r *mutationResolver) UploadTransactionsXLSXFile(ctx context.Context, file graphql.Upload) (bool, error) {
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return false, fmt.Errorf("failed to read uploaded file: %w", err)
	}

	res := &xlsConverterPkg.ConvertXLSFileToXLSXResponse{
		FileName: file.Filename,
		Data:     fileBytes,
	}
	if msgBytes, err := json.Marshal(res); err != nil {
		return false, fmt.Errorf("failed to marshal request: %w", err)
	} else if resp := r.Redis.Do(ctx, r.Redis.B().Publish().Channel(InputXLSXChannel).Message(string(msgBytes)).Build()); resp.Error() != nil {
		return false, fmt.Errorf("failed to publish request: %w", resp.Error())
	} else {
		return true, nil
	}
}

// Roots is the resolver for the roots field.
func (r *queryResolver) Roots(ctx context.Context) ([]*model.Account, error) {
	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	// language=Cypher
	const getRootCypher = `
MATCH (root:Account) 
WHERE NOT exists ((root)-[:ChildOf]->(:Account)) 
RETURN root`
	result, err := session.Run(ctx, getRootCypher, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get root account: %w", err)
	}

	records, err := result.Collect(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get root account records: %w", err)
	}

	accounts := make([]*model.Account, 0)
	for _, rec := range records {
		node := rec.Values[0].(neo4j.Node)
		accounts = append(accounts, &model.Account{
			ID:          node.Props["accountID"].(string),
			DisplayName: node.Props["displayName"].(string),
			Labels:      nil, // TODO: fetch child node labels
			Annotations: nil, // TODO: fetch child node annotations
		})
	}
	return accounts, nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {
	session := GetNeo4jSession(ctx, r.Neo4j)
	defer session.Close(ctx)

	// language=Cypher
	const getAccountCypher = `MATCH (account:Account {accountID: $accountID}) RETURN account`
	result, err := session.Run(ctx, getAccountCypher, map[string]any{"accountID": id})
	if err != nil {
		return nil, fmt.Errorf("failed to get account: %w", err)
	}

	if result.Next(ctx) {
		record := result.Record()
		node := record.Values[0].(neo4j.Node)
		account := &model.Account{
			ID:          node.Props["accountID"].(string),
			DisplayName: node.Props["displayName"].(string),
			Labels:      nil, // TODO: fetch root node labels
			Annotations: nil, // TODO: fetch root node annotations
		}
		return account, nil
	} else if result.Err() != nil {
		return nil, fmt.Errorf("failed to get account record: %w", err)
	} else {
		return nil, nil
	}
}

// Account returns AccountResolver implementation.
func (r *Resolver) Account() AccountResolver { return &accountResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type accountResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
