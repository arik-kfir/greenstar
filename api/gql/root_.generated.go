// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/arikkfir/greenstar/api/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Account() AccountResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		Children    func(childComplexity int) int
		DisplayName func(childComplexity int) int
		ID          func(childComplexity int) int
		Labels      func(childComplexity int) int
		Parent      func(childComplexity int) int
	}

	KeyAndValue struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Mutation struct {
		CreateAccount              func(childComplexity int, input model.NewAccount) int
		CreateTransaction          func(childComplexity int, input model.NewTransaction) int
		CreateTransactions         func(childComplexity int, inputs []*model.NewTransaction) int
		DeleteAccount              func(childComplexity int, id string) int
		UpdateAccount              func(childComplexity int, id string, input model.AccountUpdate) int
		UploadTransactionsXLSFile  func(childComplexity int, file graphql.Upload) int
		UploadTransactionsXLSXFile func(childComplexity int, file graphql.Upload) int
	}

	Query struct {
		Account func(childComplexity int, id string) int
		Roots   func(childComplexity int) int
	}

	Tenant struct {
		DisplayName func(childComplexity int) int
		ID          func(childComplexity int) int
		Slug        func(childComplexity int) int
	}

	Transaction struct {
		Amount        func(childComplexity int) int
		Date          func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		ReferenceID   func(childComplexity int) int
		SourceAccount func(childComplexity int) int
		TargetAccount func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.children":
		if e.complexity.Account.Children == nil {
			break
		}

		return e.complexity.Account.Children(childComplexity), true

	case "Account.displayName":
		if e.complexity.Account.DisplayName == nil {
			break
		}

		return e.complexity.Account.DisplayName(childComplexity), true

	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true

	case "Account.labels":
		if e.complexity.Account.Labels == nil {
			break
		}

		return e.complexity.Account.Labels(childComplexity), true

	case "Account.parent":
		if e.complexity.Account.Parent == nil {
			break
		}

		return e.complexity.Account.Parent(childComplexity), true

	case "KeyAndValue.key":
		if e.complexity.KeyAndValue.Key == nil {
			break
		}

		return e.complexity.KeyAndValue.Key(childComplexity), true

	case "KeyAndValue.value":
		if e.complexity.KeyAndValue.Value == nil {
			break
		}

		return e.complexity.KeyAndValue.Value(childComplexity), true

	case "Mutation.createAccount":
		if e.complexity.Mutation.CreateAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAccount(childComplexity, args["input"].(model.NewAccount)), true

	case "Mutation.createTransaction":
		if e.complexity.Mutation.CreateTransaction == nil {
			break
		}

		args, err := ec.field_Mutation_createTransaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTransaction(childComplexity, args["input"].(model.NewTransaction)), true

	case "Mutation.createTransactions":
		if e.complexity.Mutation.CreateTransactions == nil {
			break
		}

		args, err := ec.field_Mutation_createTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTransactions(childComplexity, args["inputs"].([]*model.NewTransaction)), true

	case "Mutation.deleteAccount":
		if e.complexity.Mutation.DeleteAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAccount(childComplexity, args["id"].(string)), true

	case "Mutation.updateAccount":
		if e.complexity.Mutation.UpdateAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAccount(childComplexity, args["id"].(string), args["input"].(model.AccountUpdate)), true

	case "Mutation.uploadTransactionsXLSFile":
		if e.complexity.Mutation.UploadTransactionsXLSFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadTransactionsXLSFile_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadTransactionsXLSFile(childComplexity, args["file"].(graphql.Upload)), true

	case "Mutation.uploadTransactionsXLSXFile":
		if e.complexity.Mutation.UploadTransactionsXLSXFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadTransactionsXLSXFile_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadTransactionsXLSXFile(childComplexity, args["file"].(graphql.Upload)), true

	case "Query.account":
		if e.complexity.Query.Account == nil {
			break
		}

		args, err := ec.field_Query_account_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Account(childComplexity, args["id"].(string)), true

	case "Query.roots":
		if e.complexity.Query.Roots == nil {
			break
		}

		return e.complexity.Query.Roots(childComplexity), true

	case "Tenant.displayName":
		if e.complexity.Tenant.DisplayName == nil {
			break
		}

		return e.complexity.Tenant.DisplayName(childComplexity), true

	case "Tenant.id":
		if e.complexity.Tenant.ID == nil {
			break
		}

		return e.complexity.Tenant.ID(childComplexity), true

	case "Tenant.slug":
		if e.complexity.Tenant.Slug == nil {
			break
		}

		return e.complexity.Tenant.Slug(childComplexity), true

	case "Transaction.amount":
		if e.complexity.Transaction.Amount == nil {
			break
		}

		return e.complexity.Transaction.Amount(childComplexity), true

	case "Transaction.Date":
		if e.complexity.Transaction.Date == nil {
			break
		}

		return e.complexity.Transaction.Date(childComplexity), true

	case "Transaction.description":
		if e.complexity.Transaction.Description == nil {
			break
		}

		return e.complexity.Transaction.Description(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.referenceID":
		if e.complexity.Transaction.ReferenceID == nil {
			break
		}

		return e.complexity.Transaction.ReferenceID(childComplexity), true

	case "Transaction.sourceAccount":
		if e.complexity.Transaction.SourceAccount == nil {
			break
		}

		return e.complexity.Transaction.SourceAccount(childComplexity), true

	case "Transaction.targetAccount":
		if e.complexity.Transaction.TargetAccount == nil {
			break
		}

		return e.complexity.Transaction.TargetAccount(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccountUpdate,
		ec.unmarshalInputKeyAndValueInput,
		ec.unmarshalInputNewAccount,
		ec.unmarshalInputNewTransaction,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/account.graphqls", Input: `type Account {
  id: ID!
  displayName: String!
  labels: [KeyAndValue!]!
  children: [Account!]!
  parent: Account
}
`, BuiltIn: false},
	{Name: "../schema/mutations.graphqls", Input: `scalar Upload

input NewAccount {
  id: String
  displayName: String!
  labels: [KeyAndValueInput!]
  parentID: ID
}

input AccountUpdate {
  displayName: String
  labels: [KeyAndValueInput!]
  parentID: ID
}

input NewTransaction {
  Date: Time!
  targetAccountID: ID!
  sourceAccountID: ID!
  referenceID: String!
  amount: Money!
  description: String!
}

type Mutation {
  createAccount(input: NewAccount!): Account!
  updateAccount(id: ID!, input: AccountUpdate!): Account!
  deleteAccount(id: ID!): ID!
  createTransaction(input: NewTransaction!): Transaction!
  createTransactions(inputs: [NewTransaction!]!): Int!
  uploadTransactionsXLSFile(file: Upload!): Boolean!
  uploadTransactionsXLSXFile(file: Upload!): Boolean!
}
`, BuiltIn: false},
	{Name: "../schema/queries.graphqls", Input: `type Query {
  roots: [Account!]!
  account(id: ID!): Account
}
`, BuiltIn: false},
	{Name: "../schema/tenant.graphqls", Input: `type Tenant {
    id: ID!
    displayName: String!
    slug: String!
}
`, BuiltIn: false},
	{Name: "../schema/transaction.graphqls", Input: `scalar Time
scalar Money

type Transaction {
  id: ID!
  Date: Time!
  targetAccount: Account!
  sourceAccount: Account!
  referenceID: String!
  amount: Money!
  description: String!
}
`, BuiltIn: false},
	{Name: "../schema/util.graphqls", Input: `type KeyAndValue {
  key: String!
  value: String!
}

input KeyAndValueInput {
    key: String!
    value: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
