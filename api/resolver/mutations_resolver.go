package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/arikkfir/greenstar/api/gql"
	"github.com/arikkfir/greenstar/api/model"
	"github.com/google/uuid"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input model.NewAccount) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	var id string
	if input.ID == nil {
		id = uuid.NewString()
	} else {
		id = *input.ID
	}

	createAccountParams := map[string]interface{}{}

	createAccountQuery := `// Create account
CREATE (account:Account {accountID: $accountID, displayName: $displayName})`
	createAccountParams["accountID"] = id
	createAccountParams["displayName"] = input.DisplayName

	if input.ParentID != nil {
		createAccountQuery += "WITH account\n"
		createAccountQuery += "MATCH (parent:Account {accountID: $parentAccountID})\n"
		createAccountQuery += "CREATE (account)-[:ChildOf]->(parent)\n"
		createAccountParams["parentAccountID"] = input.ParentID
	}

	for i, kv := range input.Labels {
		createAccountQuery += fmt.Sprintf("MERGE (label:Label {name: $labelName%d})\n", i)
		createAccountQuery += fmt.Sprintf("MERGE (account)-[r:HasLabel {value: $labelValue%d}]->(label)\n", i)
		createAccountParams["labelName"+strconv.Itoa(i)] = kv.Key
		createAccountParams["labelValue"+strconv.Itoa(i)] = kv.Value
	}

	createAccountQuery += "RETURN account"

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		result, err := tx.Run(ctx, createAccountQuery, createAccountParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		if len(records) == 0 {
			return nil, fmt.Errorf("no records returned")
		}

		if len(records) > 1 {
			return nil, fmt.Errorf("too many records returned")
		}

		return r.readAccount(records[0].Values[0].(neo4j.Node)), nil
	})
	if v == nil {
		return nil, err
	} else {
		return v.(*model.Account), err
	}
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, id string, input model.AccountUpdate) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	updateAccountParams := map[string]interface{}{}

	updateAccountQuery := `// Update account
MATCH (account:Account {accountID: $accountID})`
	updateAccountParams["accountID"] = id

	if input.DisplayName != nil {
		updateAccountQuery += "SET account.displayName = $displayName\n"
		updateAccountParams["displayName"] = *input.DisplayName
	}

	if input.ParentID != nil {
		updateAccountQuery += "WITH account\n"
		updateAccountQuery += "OPTIONAL MATCH (account)-[oldChildOfRel:ChildOf]->(oldParent:Account)\n"
		updateAccountQuery += "WHERE oldParent.accountID <> $parentAccountID\n"
		updateAccountQuery += "DELETE oldChildOfRel\n"
		updateAccountQuery += "WITH account\n"
		updateAccountQuery += "MERGE (parent:Account {accountID: $parentAccountID})\n"
		updateAccountQuery += "MERGE (account)-[:ChildOf]->(parent)\n"
		updateAccountParams["parentAccountID"] = *input.ParentID
	}

	for i, kv := range input.Labels {
		updateAccountQuery += "OPTIONAL MATCH (account)-[oldLabelRel:HasLabel]->(:Label)\n"
		updateAccountQuery += "DELETE oldLabelRel\n"
		updateAccountQuery += "WITH account\n"
		updateAccountQuery += fmt.Sprintf("MERGE (label:Label {name: $labelName%d})\n", i)
		updateAccountQuery += fmt.Sprintf("MERGE (account)-[r:HasLabel {value: $labelValue%d}]->(label)\n", i)
		updateAccountParams["labelName"+strconv.Itoa(i)] = kv.Key
		updateAccountParams["labelValue"+strconv.Itoa(i)] = kv.Value
	}

	updateAccountQuery += "RETURN account"

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		result, err := tx.Run(ctx, updateAccountQuery, updateAccountParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		if len(records) == 0 {
			return nil, fmt.Errorf("no records returned")
		}

		if len(records) > 1 {
			return nil, fmt.Errorf("too many records returned")
		}

		return r.readAccount(records[0].Values[0].(neo4j.Node)), nil
	})
	return v.(*model.Account), err
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (string, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {

		//language=Cypher
		const deleteAccountQuery = `// Delete account
MATCH (account:Account {accountID: $accountID})
DELETE account`

		result, err := tx.Run(ctx, deleteAccountQuery, map[string]any{"accountID": id})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		summary, err := result.Consume(ctx)
		if err != nil {
			return "", fmt.Errorf("failed to consume query summary: %w", err)
		}

		if summary.Counters().NodesDeleted() != 1 {
			return id, fmt.Errorf("no records deleted")
		}
		return id, nil
	})
	return v.(string), err
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.NewTransaction) (*model.Transaction, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		id := uuid.NewString()

		createTxQuery := `// Create transaction
MATCH (sourceAccount:Account {accountID: $sourceAccountID})
MATCH (targetAccount:Account {accountID: $targetAccountID})
CREATE (sourceAccount)-[r:TransferredTo {txID: $id, date: $date, refID: $refID, amount: $amount, description: $description}]->(targetAccount)
RETURN sourceAccount, r, targetAccount`
		createTxParams := map[string]interface{}{}
		createTxParams["sourceAccountID"] = input.SourceAccountID
		createTxParams["targetAccountID"] = input.TargetAccountID
		createTxParams["id"] = id
		createTxParams["date"] = input.Date
		createTxParams["refID"] = input.ReferenceID
		createTxParams["amount"] = input.Amount
		createTxParams["description"] = input.Description

		result, err := tx.Run(ctx, createTxQuery, createTxParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		if len(records) == 0 {
			return nil, fmt.Errorf("no records returned")
		}

		if len(records) > 1 {
			return nil, fmt.Errorf("too many records returned")
		}

		txRel := records[0].Values[1].(neo4j.Relationship)
		return &model.Transaction{
			ID:            txRel.Props["txID"].(string),
			Date:          txRel.Props["date"].(time.Time),
			TargetAccount: r.readAccount(records[0].Values[2].(neo4j.Node)),
			SourceAccount: r.readAccount(records[0].Values[0].(neo4j.Node)),
			ReferenceID:   txRel.Props["refID"].(string),
			Amount:        txRel.Props["amount"].(model.Money),
			Description:   txRel.Props["description"].(string),
		}, nil
	})
	return v.(*model.Transaction), err
}

// CreateTransactions is the resolver for the createTransactions field.
func (r *mutationResolver) CreateTransactions(ctx context.Context, inputs []*model.NewTransaction) (int, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeWrite)
	defer session.Close(ctx)

	v, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		createTxQuery := `// Create transactions list`
		createTxParams := map[string]interface{}{}

		for i, input := range inputs {
			createTxQuery += fmt.Sprintf(`// Create transaction %d
MATCH (sourceAccount%d:Account {accountID: $sourceAccountID%d})
MATCH (targetAccount%d:Account {accountID: $targetAccountID%d})
CREATE (sourceAccount%d)-[:TransferredTo {
	txID: $id%d, 
	date: $date%d, 
	refID: $refID%d, 
	amount: $amount%d, 
	description: $description%d
}]->(targetAccount%d)`,
				i, i, i, i, i, i, i, i, i, i, i, i)
			createTxParams["sourceAccountID"+strconv.Itoa(i)] = input.SourceAccountID
			createTxParams["targetAccountID"+strconv.Itoa(i)] = input.TargetAccountID
			createTxParams["id"+strconv.Itoa(i)] = uuid.NewString()
			createTxParams["date"+strconv.Itoa(i)] = input.Date
			createTxParams["refID"+strconv.Itoa(i)] = input.ReferenceID
			createTxParams["amount"+strconv.Itoa(i)] = input.Amount
			createTxParams["description"+strconv.Itoa(i)] = input.Description
		}

		result, err := tx.Run(ctx, createTxQuery, createTxParams)
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		summary, err := result.Consume(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to consume query summary: %w", err)
		}

		relationshipsCreated := summary.Counters().RelationshipsCreated()
		if relationshipsCreated != len(inputs) {
			return nil, fmt.Errorf("incorrect number of transaction relationships created, expected %d, got %d", len(inputs), relationshipsCreated)
		}

		return relationshipsCreated, nil
	})
	return v.(int), err
}

// UploadTransactionsXLSFile is the resolver for the uploadTransactionsXLSFile field.
func (r *mutationResolver) UploadTransactionsXLSFile(ctx context.Context, file graphql.Upload) (bool, error) {
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return false, fmt.Errorf("failed to read uploaded file: %w", err)
	}

	msg, err := json.Marshal(fileBytes)
	if err != nil {
		return false, fmt.Errorf("failed to marshal XLS conversion request to JSON: %w", err)
	}

	cmd := r.Redis.B().Publish().Channel(convertXLSChannelName).Message(string(msg)).Build()
	if resp := r.Redis.Do(ctx, cmd); resp.Error() != nil {
		return false, fmt.Errorf("failed to publish request: %w", resp.Error())
	}

	return true, nil
}

// UploadTransactionsXLSXFile is the resolver for the uploadTransactionsXLSXFile field.
func (r *mutationResolver) UploadTransactionsXLSXFile(ctx context.Context, file graphql.Upload) (bool, error) {
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return false, fmt.Errorf("failed to read uploaded file: %w", err)
	}

	msg, err := json.Marshal(fileBytes)
	if err != nil {
		return false, fmt.Errorf("failed to marshal XLS conversion request to JSON: %w", err)
	}

	cmd := r.Redis.B().Publish().Channel(processXLSXChannelName).Message(string(msg)).Build()
	if resp := r.Redis.Do(ctx, cmd); resp.Error() != nil {
		return false, fmt.Errorf("failed to publish request: %w", resp.Error())
	}

	return true, nil
}

// Mutation returns gql.MutationResolver implementation.
func (r *Resolver) Mutation() gql.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
