package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"

	"github.com/arikkfir/greenstar/api/gql"
	"github.com/arikkfir/greenstar/api/model"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// Labels is the resolver for the labels field.
func (r *accountResolver) Labels(ctx context.Context, obj *model.Account) ([]*model.KeyAndValue, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {

		//language=Cypher
		const getLabelsCypher = `// Get account labels
MATCH (acc:Account {accountID: $accountID})-[r:HasLabel]->(l:Label)
RETURN l.name, r.value`

		result, err := tx.Run(ctx, getLabelsCypher, map[string]any{"accountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		var labels []*model.KeyAndValue
		for _, record := range records {
			labels = append(labels, &model.KeyAndValue{
				Key:   record.Values[0].(string),
				Value: record.Values[1].(string),
			})
		}
		return labels, nil
	})
	return v.([]*model.KeyAndValue), err
}

// Children is the resolver for the children field.
func (r *accountResolver) Children(ctx context.Context, obj *model.Account) ([]*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {

		//language=Cypher
		const getChildrenCypher = `// Get account children
MATCH (acc:Account)-[:ChildOf]->(parent:Account {accountID: $accountID})
RETURN acc`

		result, err := tx.Run(ctx, getChildrenCypher, map[string]any{"accountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		accounts := make([]*model.Account, 0)
		for _, rec := range records {
			accounts = append(accounts, r.readAccount(rec.Values[0].(neo4j.Node)))
		}
		return accounts, nil
	})
	return v.([]*model.Account), err
}

// Parent is the resolver for the parent field.
func (r *accountResolver) Parent(ctx context.Context, obj *model.Account) (*model.Account, error) {
	session := r.getNeo4jSession(ctx, neo4j.AccessModeRead)
	defer session.Close(ctx)

	v, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {

		//language=Cypher
		const getParentCypher = `// Get account parent
MATCH (child:Account {accountID: $accountID})-[:ChildOf]->(parent:Account) 
RETURN parent`

		result, err := tx.Run(ctx, getParentCypher, map[string]any{"accountID": obj.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to execute query: %w", err)
		}

		records, err := result.Collect(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to collect records: %w", err)
		}

		if len(records) == 0 {
			return nil, nil
		}

		if len(records) > 1 {
			return nil, fmt.Errorf("too many records")
		}

		return r.readAccount(records[0].Values[0].(neo4j.Node)), nil
	})
	return v.(*model.Account), err
}

// Account returns gql.AccountResolver implementation.
func (r *Resolver) Account() gql.AccountResolver { return &accountResolver{r} }

type accountResolver struct{ *Resolver }
